"""Enhanced Django project analyzer (Phase 1 complete version).Scans for Django files in arbitrary layouts and extracts models, views, URLs, and DRF serializers."""import astimport reimport structlogfrom pathlib import Pathfrom typing import Dict, List, Any, Optional, Setlogger = structlog.get_logger()# ---------------------------------------------------------------------------# File-system scan helpers# ---------------------------------------------------------------------------class DjangoFileScanner:    """Locate Django-related files anywhere inside a project tree."""    # filename patterns per category    PATTERNS: Dict[str, List[str]] = {        "models": ["models.py"],        "views": ["views.py", "viewsets.py"],        "urls": ["urls.py"],        "serializers": ["serializers.py"],    }    def __init__(self, project_root: str):        self.root = Path(project_root).resolve()        self.files: Dict[str, List[Path]] = {k: [] for k in self.PATTERNS}    def scan(self):        skip = {".git", "__pycache__", "venv", "env", ".venv"}        for path in self.root.rglob("*.py"):            if any(part in skip for part in path.parts):                continue            name = path.name.lower()            for cat, patterns in self.PATTERNS.items():                if name in patterns:                    self.files[cat].append(path)                    break# ---------------------------------------------------------------------------# Enhanced analyzer# ---------------------------------------------------------------------------class DjangoAnalyzer:    """Analyze a Django project by AST-parsing discovered Django files."""    def __init__(self, project_path: str):        self.root = Path(project_path).resolve()        self.scanner = DjangoFileScanner(project_path)        self.models: Dict[str, List[Dict[str, Any]]] = {}        self.views: Dict[str, List[Dict[str, Any]]] = {}        self.urls: Dict[str, List[Dict[str, Any]]] = {}        self.serializers: Dict[str, List[Dict[str, Any]]] = {}    # ------------- public API -------------    def analyze(self) -> Dict[str, Any]:        logger.info("analyzing_django_project", path=str(self.root))        self.scanner.scan()        self._analyze_models()        self._analyze_views()        self._analyze_urls()        self._analyze_serializers()        return {            "apps": sorted({p.parent.name for cat in self.scanner.files.values() for p in cat}),            "models": self.models,            "views": self.views,            "urls": self.urls,            "serializers": self.serializers,            "testable_endpoints": self._make_endpoints(),        }    # ------------- analysis helpers -------------    def _group_by_app(self, path: Path) -> str:        return path.parent.name    def _analyze_models(self):        for file in self.scanner.files["models"]:            app = self._group_by_app(file)            self.models.setdefault(app, []).extend(self._parse_models(file))    def _parse_models(self, file: Path) -> List[Dict[str, Any]]:        res: List[Dict[str, Any]] = []        tree = ast.parse(file.read_text())        for node in ast.walk(tree):            if isinstance(node, ast.ClassDef) and self._is_model(node):                res.append({                    "name": node.name,                    "file": str(file),                    "fields": self._model_fields(node),                })        return res    @staticmethod    def _is_model(node: ast.ClassDef) -> bool:        return any(            (isinstance(b, ast.Attribute) and b.attr == "Model") or (isinstance(b, ast.Name) and b.id.endswith("Model"))            for b in node.bases        )    @staticmethod    def _model_fields(node: ast.ClassDef) -> List[str]:        fields = []        for item in node.body:            if isinstance(item, ast.Assign):                for t in item.targets:                    if isinstance(t, ast.Name):                        fields.append(t.id)        return fields    def _analyze_views(self):        for file in self.scanner.files["views"]:            app = self._group_by_app(file)            self.views.setdefault(app, []).extend(self._parse_views(file))    def _parse_views(self, file: Path) -> List[Dict[str, Any]]:        tree = ast.parse(file.read_text())        views = []        for node in ast.walk(tree):            if isinstance(node, ast.FunctionDef):                if node.args.args and node.args.args[0].arg == "request":                    views.append({"name": node.name, "type": "function", "file": str(file)})            elif isinstance(node, ast.ClassDef):                if any(base for base in node.bases if isinstance(base, ast.Name) and base.id.endswith("View")):                    views.append({"name": node.name, "type": "class", "file": str(file)})        return views    def _analyze_urls(self):        url_regex = re.compile(r"path\s*\(\s*[r]?['\"](.*?)['\"]\s*,\s*([^,]+)")        for file in self.scanner.files["urls"]:            app = self._group_by_app(file)            content = file.read_text()            matches = url_regex.findall(content)            for pattern, view in matches:                self.urls.setdefault(app, []).append({"pattern": pattern, "view": view.strip(), "file": str(file)})    def _analyze_serializers(self):        for file in self.scanner.files["serializers"]:            app = self._group_by_app(file)            self.serializers.setdefault(app, []).append({"file": str(file)})    # ------------- endpoints -------------    def _make_endpoints(self) -> List[Dict[str, Any]]:        endpoints = []        for app, patterns in self.urls.items():            for url in patterns:                endpoints.append({                    "app": app,                    "url": url["pattern"],                    "view": url["view"],                    "methods": ["GET", "POST", "PUT", "DELETE"],                })        return endpoints        def __init__(self, project_path: str):        self.project_path = Path(project_path)        self.apps: Dict[str, Path] = {}        self.models: Dict[str, Any] = {}        self.views: Dict[str, Any] = {}        self.urls: Dict[str, Any] = {}    def analyze(self) -> Dict[str, Any]:        """Analyze Django project structure and return high-level metadata."""        logger.info("analyzing_django_project", path=str(self.project_path))        self._find_apps()        for app_name, app_path in self.apps.items():            self._analyze_app(app_name, app_path)        return {            "apps": list(self.apps.keys()),            "models": self.models,            "views": self.views,            "urls": self.urls,            "testable_endpoints": self._extract_testable_endpoints(),        }    # ------------------------- internal helpers -------------------------    def _find_apps(self):        for item in self.project_path.iterdir():            if item.is_dir() and (item / "__init__.py").exists():                if (item / "models.py").exists() or (item / "views.py").exists():                    self.apps[item.name] = item    def _analyze_app(self, app_name: str, app_path: Path):        models_file = app_path / "models.py"        if models_file.exists():            self.models[app_name] = self._analyze_models(models_file)        views_file = app_path / "views.py"        if views_file.exists():            self.views[app_name] = self._analyze_views(views_file)        urls_file = app_path / "urls.py"        if urls_file.exists():            self.urls[app_name] = self._analyze_urls(urls_file)    # ---- model parsing ----    def _analyze_models(self, file_path: Path) -> List[Dict[str, Any]]:        models: List[Dict[str, Any]] = []        tree = ast.parse(file_path.read_text())        for node in ast.walk(tree):            if isinstance(node, ast.ClassDef):                if any(isinstance(base, ast.Attribute) and base.attr == "Model" for base in node.bases):                    models.append({                        "name": node.name,                        "fields": self._extract_model_fields(node),                        "methods": [m.name for m in node.body if isinstance(m, ast.FunctionDef)],                    })        return models    def _extract_model_fields(self, class_node: ast.ClassDef) -> List[Dict[str, str]]:        fields: List[Dict[str, str]] = []        for node in class_node.body:            if isinstance(node, ast.Assign):                for target in node.targets:                    if isinstance(target, ast.Name):                        field_type = "Unknown"                        if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Attribute):                            field_type = node.value.func.attr                        fields.append({"name": target.id, "type": field_type})        return fields    # ---- views parsing ----    def _analyze_views(self, file_path: Path) -> List[Dict[str, Any]]:        views: List[Dict[str, Any]] = []        tree = ast.parse(file_path.read_text())        for node in ast.walk(tree):            if isinstance(node, ast.ClassDef):                view_info = {"name": node.name, "type": "class-based", "methods": []}                for item in node.body:                    if isinstance(item, ast.FunctionDef):                        view_info["methods"].append(item.name)                views.append(view_info)            elif isinstance(node, ast.FunctionDef):                views.append({                    "name": node.name,                    "type": "function-based",                    "decorators": [d.id for d in node.decorator_list if isinstance(d, ast.Name)],                })        return views    # ---- urls parsing ----    def _analyze_urls(self, file_path: Path) -> List[Dict[str, str]]:        urls: List[Dict[str, str]] = []        pattern = r"path\([\'\"]([^\'\"]*)[\'\"]\s*,\s*([^,)]+)"        for url_pattern, view_name in re.findall(pattern, file_path.read_text()):            urls.append({"pattern": url_pattern, "view": view_name.strip()})        return urls    def _extract_testable_endpoints(self) -> List[Dict[str, Any]]:        endpoints: List[Dict[str, Any]] = []        for app_name in self.apps:            for url in self.urls.get(app_name, []):                endpoints.append({                    "app": app_name,                    "url": url["pattern"],                    "view": url["view"],                    "methods": ["GET", "POST", "PUT", "DELETE"],                })        return endpoints
